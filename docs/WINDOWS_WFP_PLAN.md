# Windows: полный туннель без WinDivert inject (WFP и Wintun)

WinDivert 2.2 не даёт инжектить **входящие** пакеты (ошибка 87). Ниже два реальных варианта — оба **вполне реализуемы**, не теория.

---

## Вариант 1: Wintun (TUN) — рекомендуемый первый шаг

**Суть:** виртуальный интерфейс (как на Linux). Трафик в 10.10.0.0/24 идёт в TUN; мы читаем пакеты из TUN и пишем в туннель; с туннеля приходят пакеты — мы **пишем в TUN**, стек их получает. Никакого WinDivert Send.

| Плюсы | Минусы |
|-------|--------|
| Нет своего kernel-кода: только драйвер Wintun (уже подписан, от WireGuard) | Нужно настроить маршруты и адрес на TUN (10.10.0.2/24) |
| Готовые Go-биндинги: `golang.zx2c4.com/wintun` | Если были ошибки — их нужно воспроизвести и исправить |
| Входящие пакеты просто пишем в TUN — без инжекта |
| Реально используется в продакшене (WireGuard и др.) |

**Реализуемость:** высокая. Если раньше были ошибки с Wintun — имеет смысл их добить: типичные проблемы — путь к `wintun.dll`, имя адаптера, права, маршруты. Обычно решаемо за день–два.

**Безопасность:** мы **не пишем** свой kernel-код. Драйвер Wintun — узкая задача (TUN, приём/выдача пакетов), один и тот же бинарник используют WireGuard, Tailscale и др.; поверхность атаки в ядре не увеличивается нашим кодом. Риск только в доверии к бинарнику Wintun и в нашем user-mode коде.

**Шаги:** создать адаптер Wintun, выставить 10.10.0.2/24, направить маршрут (или default) в TUN; цикл: ReceivePacket → в туннель; из туннеля → SendPacket. Логика туннеля уже есть в Divert-клиенте.

**Права:** создание адаптера Wintun и маршрутов требует **прав администратора**. Если в логе видно `tun create failed: Access is denied` или `Failed to create private namespace: Отказано в доступе` — запускайте **astra-gui.exe** или **astra-tun-client.exe** от имени администратора (правый клик → «Запуск от имени администратора»).

### Управление маршрутами и интерфейс (чтобы интернет не падал)

Проблема: вручную добавленный маршрут при аварийном выходе клиента остаётся — весь трафик уходит в TUN, интернет «пропадает», пока маршрут не удалишь. Нужно делать всё автоматом и предсказуемо.

**1. Строгий жизненный цикл в коде**

- **Старт:** создать TUN → выставить IP (10.10.0.2/24) → добавить только те маршруты, которые нужны (см. ниже).
- **Стоп (всегда один и тот же путь):** сначала удалить все маршруты, которые мы добавили → закрыть TUN. Один и тот же код вызывать при: нормальном выходе, Ctrl+C, нажатии «Отключить» в GUI, закрытии окна.
- В Go: хранить список добавленных маршрутов (destination + interface), в `defer` или в обработчике сигнала вызывать `removeRoutes()` → `tun.Close()`. Никогда не выходить из процесса, не выполнив очистку.

**2. Очистка при следующем старте (защита от падения)**

- В самом начале старта: **удалить** любые маршруты, которые указывают на наш TUN-интерфейс (по LUID или имени адаптера). Так, даже если прошлый запуск упал и не снял маршруты, при новом запуске интернет не остаётся «сломанным».
- После этого добавлять маршруты заново. Итог: один источник правды — «те маршруты, что мы только что добавили»; старые от прошлого запуска не висят.

**3. Не persistent-маршруты**

- На Windows добавлять маршруты **без** флага persistent. Тогда после перезагрузки ПК «забытые» маршруты всё равно исчезнут. Для работы клиента persistent не нужен.

**4. Split tunnel (опция)**

- Вместо одного маршрута 0.0.0.0/0 в TUN можно по умолчанию пускать в туннель только часть трафика (например, 0.0.0.0/1 и 128.0.0.0/1, с исключением локальных сетей). Тогда при сбое часть интернета (LAN, возможно часть внешних) остаётся без TUN. Полный default route — только если пользователь явно выбрал «весь трафик через VPN».

**5. Интеграция с GUI**

- **Единая точка «стоп»:** GUI не дергает маршруты сам — у него есть только «Подключить» и «Отключить». «Отключить» вызывает в клиенте один метод типа `Shutdown()` / `Disconnect()`, который: разрывает туннель, удаляет маршруты, закрывает TUN. Так и консольный клиент, и GUI используют один и тот же код очистки.
- **Блокирующее отключение:** по нажатию «Отключить» GUI показывает «Отключаем…», ждёт завершения `Shutdown()` (с таймаутом 5–10 с), потом пишет «Отключено». Пользователь видит, что отключение прошло до конца.
- **Автоотключение при ошибке:** если туннель падает по ошибке (нет связи с Entry и т.д.), клиент сам вызывает тот же `Shutdown()` — маршруты снимаются, TUN закрывается, интернет возвращается. GUI можно только уведомить (callback/событие) и показать «Подключение разорвано».
- **Системный трей (опционально):** иконка «подключено» / «отключено»; правый клик → «Отключить» снова вызывает тот же `Shutdown()`.

**6. Кратко по реализации**

- В коде клиента: пакет `tun` (или `wintun`) с типами `Adapter`, `Session` и функцией «добавить/удалить маршрут по интерфейсу» (через `netsh` или WinAPI `CreateIpForwardEntry` / `DeleteIpForwardEntry` или `Route —p add/delete` без `-p`). При старте — список маршрутов в память; при стопе — пройти список и удалить; при следующем старте — сначала удалить по нашему интерфейсу всё, что осталось.
- GUI: только кнопки Подключить/Отключить и вызов одного и того же движка (библиотека или пакет, который можно вызывать и из CLI, и из GUI). Так «каждый раз не открывать маршрут вручную» и «не оставаться с сломанным интернетом» решаются автоматом.

---

## Вариант 2: WFP (Windows Filtering Platform)

**Суть:** перехват на уровне **connect**; драйвер перенаправляет TCP на наш localhost-прокси; мы поднимаем туннель и проксируем. Входящий трафик идёт по уже установленному TCP.

- Исходящий: `connect(1.1.1.1, 443)` → WFP redirect в наш прокси → туннель до Entry/Exit.
- Входящий: по уже установленному TCP через прокси — инжект не нужен.

**Реализуемость:** да, делаемо (так работают многие VPN на Windows), но объём работы больше: свой kernel-драйвер, WDK, подпись. Имеет смысл после того, как попробовали Wintun.

**Безопасность:** свой драйвер = **новый код в ядре**. Любая ошибка (переполнение буфера, логика классификации, обработка redirect) может привести к падению системы или компрометации. Драйвер нужно разрабатывать, аудитить и сопровождать. По уровню риска это хуже, чем использовать готовый узкий драйвер (Wintun), в который мы не добавляем свой код.

---

## WFP — детали (если пойдёте этим путём)

### Сложность: средне‑высокая

| Часть | Сложность | Что нужно |
|------|-----------|-----------|
| **Драйвер (kernel)** | Высокая | C/C++, WDK, подпись драйвера, отладка |
| **Агент (user-mode, Go)** | Средняя | Прокси уже есть; нужно только получать original-dst и стыковать с туннелем |
| **Сборка и деплой** | Средняя | WDK, тестовая подпись или EV-сертификат, установка драйвера |

## Что потребуется

### 1. Окружение для драйвера

- **Windows Driver Kit (WDK)** — ставится поверх Visual Studio (или Build Tools).
- **Visual Studio 2019/2022** с компонентами «Desktop development with C++», «Windows 10/11 SDK».
- Ссылка: [Download the WDK](https://learn.microsoft.com/en-us/windows-hardware/drivers/download-the-wdk).

### 2. Драйвер (kernel callout)

- Небольшой **WFP callout driver** на C:
  - Регистрация callout на слое **ALE Connect Redirect v4** (или подходящем ALE-слое).
  - В `classifyFn`: для нужного трафика (TCP 80/443, с исключением Entry) — **перенаправить** соединение на `127.0.0.1:<порт_агента>`.
  - Опционально: передать в user-mode **original destination** (IP:port), чтобы агент знал, куда подключаться по туннелю (через socket option, shared section или другой механизм, который даёт WFP redirect).
- Подпись:
  - **Разработка:** тестовая подпись (`bcdedit /set testsigning on`, перезагрузка).
  - **Продакшен:** подпись через EV-сертификат (например, из каталога Microsoft Hardware Dev Center).

### 3. Агент (user-mode, Go) — расширение текущего клиента

- Слушает на `127.0.0.1:<порт>` (тот же, на который драйвер делает redirect).
- Для каждого **входящего** соединения от приложения:
  - Узнаёт **original destination** (куда изначально хотел connect клиент). Это приходит от драйвера (через WFP API в user-mode или через данные, которые драйвер кладёт в контекст/сокет).
  - Поднимает/использует туннель до Entry, открывает поток до нужного IP:port через Exit (как сейчас в Divert-клиенте).
  - Проксирует данные между локальным сокетом и туннелем.
- Вход в туннель (handshake, конфиг, Entry) — тот же, что в `astra-divert-client`; меняется только способ «перехвата» трафика: не пакеты по WinDivert, а connect-redirect по WFP.

### 4. Установка и запуск

- Установка драйвера: `sc create`, или инф-файл, или свой installer.
- Запуск: драйвер загружается при старте агента (или отдельной службой); агент — как сейчас, с конфигом и Entry.

## Этапы (кратко)

1. **Изучить WFP redirect** — слой ALE Connect Redirect, как передать original-dst в user-mode (документация MS, примеры).
2. **Скелет драйвера** — проект в VS, callout, классификация по портам 80/443 и исключение IP:port Entry.
3. **Тестовая подпись и загрузка** — проверка redirect на localhost.
4. **Агент** — слушает порт, получает original-dst (пока заглушка, если драйвер ещё не передаёт), подключается к туннелю и проксирует.
5. **Связка драйвер ↔ агент** — механизм передачи original-dst (SO_ORIGINAL_DST или аналог, если доступен в WFP redirect).
6. **Исключения** — не редиректить Entry (178.208.76.92:8443), не редиректить localhost и т.п.

## Полезные ссылки

- [WFP Callout Drivers](https://learn.microsoft.com/en-us/windows-hardware/drivers/network/wfp-callout-drivers)
- [ALE Connect Redirect](https://learn.microsoft.com/en-us/windows-hardware/drivers/network/using-layer-2-filtering) и слои с «redirect» в названии
- Примеры: WireGuard Windows (частично WFP), другие VPN с redirect на Windows

## Итог

- **Wintun:** реализуемо, проще (готовый драйвер + Go), входящие — запись в TUN. Имеет смысл **сначала добить Wintun** (разобрать старые ошибки), прежде чем браться за WFP.
- **WFP:** тоже реализуемо, но сложнее (свой драйвер, WDK, подпись). Рассматривать, если Wintun по каким-то причинам не подойдёт.

Рекомендация: вернуться к Wintun, зафиксировать текущие ошибки (логи, шаги), и починить их — это обычно быстрее, чем писать WFP-драйвер с нуля.

---

## Сборка TUN-клиента и GUI

**TUN-клиент (консоль, с авто-маршрутами и очисткой при выходе):**
```powershell
cd C:\Users\User\Desktop\Astra
go build -o astra-tun-client.exe .\cmd\astra-tun-client\
```
Запуск: `.\astra-tun-client.exe -config .\configs\astra-tun-client.json`  
При выходе (Ctrl+C или закрытие) маршруты снимаются, TUN закрывается. При следующем запуске сначала удаляются «забытые» маршруты от прошлого сеанса.

**GUI (кнопки Start TUN / Start Proxy, Stop):**  
Для сборки GUI нужны CGO и компилятор C (например MinGW-w64 для Windows), т.к. Fyne использует OpenGL:
```powershell
cd C:\Users\User\Desktop\Astra
go build -o astra-gui.exe .\cmd\astra-gui\
```
Если сборка выдаёт ошибку по `go-gl/gl`, установите gcc (например через `choco install mingw`) и убедитесь, что `gcc` в PATH.  
Запуск: `.\astra-gui.exe`  
В GUI: «Start TUN» при необходимости собирает и запускает TUN-клиент; «Stop» завершает процесс. Если остановить через Stop (kill), маршруты при следующем «Start TUN» очищаются автоматически при старте клиента.

---

## Как тестировать и смотреть логи

**Где логи при запуске из GUI**
- Папка: рядом с exe GUI — подпапка **`logs`** (например `C:\Users\User\Desktop\Astra\logs`).
- Кнопка в GUI: **«Open Logs Folder»** — открывает эту папку.
- Файлы для TUN-клиента:
  - **`astra-tun-client.err.log`** — сюда идут все `log.Printf` (ошибки, статус, shutdown).
  - **`astra-tun-client.out.log`** — stdout (если что-то пишется туда).

**Как тестировать**
1. Запустить GUI → **Start TUN**.
2. Открыть **Open Logs Folder** и оставить папку открытой (или открыть `astra-tun-client.err.log` в редакторе с автообновлением).
3. Проверить трафик: браузер, `ping 1.1.1.1` и т.д.
4. Если соединение рвётся — сразу смотреть **конец** `astra-tun-client.err.log`: там будет последнее сообщение перед выходом.

**По чему понимать, почему рвётся соединение**

| В логе (последние строки) | Что значит |
|---------------------------|------------|
| `conn read error: ...` | Обрыв по туннелю (сеть до Entry, или сервер закрыл соединение). |
| `tun read error: ...` | Ошибка чтения с TUN (драйвер/интерфейс). |
| `keepalive write error: ...` | Не удаётся писать в туннель — связь с Entry потеряна. |
| `tun->conn write error: ...` | Не удаётся отправить пакет в туннель (соединение уже закрыто). |
| `shutting down: removing routes...` | Нормальное отключение (по сигналу или после ошибки). |
| `handshake denied: ...` / `failed to connect to entry` | Не прошла авторизация или нет доступа к Entry (токен, сеть). |
| `tun create failed: ...` / `Access is denied` / `Отказано в доступе` | Запуск **не от администратора**. Правый клик по exe → «Запуск от имени администратора». |
| `set TUN address: ...` / `add default route: ...` | Ошибка настройки маршрутов (права админа, имя интерфейса). |

**Запуск из консоли (удобно для отладки)**  
Тогда всё пишется в терминал в реальном времени:
```powershell
cd C:\Users\User\Desktop\Astra
.\astra-tun-client.exe -config .\configs\astra-tun-client.json
```
Так сразу видно, на каком шаге упало и какое сообщение об ошибке.

---

## Клиент: tx растёт, rx=0 — что проверить на сервере

Если в логе TUN-клиента **tx растёт, а rx=0** (пакеты в туннель уходят, из туннеля ничего не приходит), ответы с Exit до клиента не доходят. «Мой IP» тогда показывает свой. Что проверить на сервере:

**1. Exit — пакеты по TUN (astra0)**  
На машине с astra-exit:
```bash
sudo tcpdump -ni astra0 -c 10
```
Должны быть пакеты от 10.10.0.2 (исходящие) и **ответы** с dst=10.10.0.2 (входящие). Если входящих нет — проблема до Exit (NAT/маршрутизация снаружи). Если входящие есть — смотреть, уходят ли они в туннель к клиенту.

**2. Exit — NAT и forward**  
Должны быть MASQUERADE для трафика с astra0 наружу и включён ip_forward:
```bash
sudo iptables -t nat -L POSTROUTING -v -n
sysctl net.ipv4.ip_forward
```
Forward = 1; правило типа `-o eth0 -j MASQUERADE` для 10.10.0.0/24.

**3. Exit — отправка ответов в туннель**  
astra-exit должен читать из TUN в т.ч. ответы (dst 10.10.0.2) и писать их в то же tunnel-соединение к клиенту. Проверить логи Exit: уходят ли пакеты «к клиенту» при появлении ответов на astra0.

**4. Entry / Relay**  
Пересылают ли кадры от Exit к клиенту без потерь (логи, session_id).
